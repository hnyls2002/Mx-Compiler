### my test commands

##### IR test in `debug/`.

`test.ll`(generated by my compiler from `test.mx`) and `builtin.ll` are both x86-64 target.

- `sh ir-test.sh`
- `sh ir-draw.sh`

##### IR auto test in `src/irtestspace`.
The `testIR` flag in `Compiler.java` should be set to `true`.
- `python3 ir-auto-test.py`

##### codegen test in `debug/`.
- `sh asm-riscv-gen.sh` to generate `test.s` in **risv32 target**.
- `sh codegen-test.sh` use `test.s`, `builtin.s` and `ravel` to execute the program.


### llvm commands

##### LLVM IR generation
- to `.ll`
  - `clang -S -emit-llvm test.c`
  - `clang -S -emit-llvm test.c --target=riscv32`
- to `.bc`
  - `clang -c -emit-llvm test.c` 

##### link LLVM IR (to bitcode)
- `llvm-link test.ll builtin.ll -o linked.bc`

##### compile LLVM IR(`.ll` or `.bc`) to executable
- `clang test.ll -o test`
- `clang test.bc -o test`

##### execute program in LLVM IR format
- `lli test.ll`
- `lli test.bc`

##### compile LLVM IR to assembly
- `llc test.ll -o test.s`
- `llc test.bc -o test.s`

##### code generation (from `.c` to `.s`)
- `clang -S test.c`
- `clang -S test.c --target=riscv32 -march=rv32im` 
`i` means basic integer instructions, `m` means multiply and divide, which we will use in code-generation phase.

##### code generation (from `.ll` to `.s`)
- `llc test.ll -o test.s -march=riscv32 -mattr=+m`
`m` tells the compiler not to use `__mul` but to use `mul` instruction.